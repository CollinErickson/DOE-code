detach("package:laGP", unload=TRUE)
library("laGP", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,g=3,func=sinumoid,  obj="grad")
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
newGPsep
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
source('sFFLHD.R')
library("UGP")
source("adaptconcept_helpers.R")
require(mlegp)
require(GPfit)
require(contourfilled)
require(TestFunctions)
source('LHS.R')
source("RFF_test.R")
source("/Users/collin/Git/SMED-Code/SMED_select.R")
source("../SMED/SMED-Code/SMED_select.R")
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
system.time(a$run(20,plotlastonly = T))
Rcpp::cppFunction('
IntegerVector SMED_select(Function f, int n, NumericMatrix X0, NumericMatrix Xopt) {
int p = X0.ncol();
int k = 4 * p;
// initiate values for X0
NumericVector Y(X0.nrow());
for (int i=0; i < Y.size(); ++i) {
Y[i] = as<double>(f(X0(i, _)));
}
NumericVector qqX(X0.nrow());
for (int i=0; i < qqX.size(); ++i) {
qqX[i] = pow(Y[i], -1.0 / (2 * p));
}
// initiate values for Xopt
NumericVector Yopt(Xopt.nrow());
for (int i=0; i < Yopt.size(); ++i) {
Yopt[i] = as<double>(f(Xopt(i, _)));
}
NumericVector qqXopt(Xopt.nrow());
for (int i=0; i < qqXopt.size(); ++i) {
qqXopt[i] = pow(Yopt[i], -1.0 / (2 * p));
}
double Delta = .01 * max(Y);
LogicalVector keepDelta = (Y > Delta);
IntegerVector XoptSelectedIndsOrder(n);
LogicalVector XoptSelected(Xopt.nrow(), false);
//double total = 0;
double dist = 0;
double funcValMin;
double funcValMinInd = -1;
double funcVal;
NumericVector funcVals(Xopt.nrow());
// Pick n next with SMED
for(int i = 0; i < n; ++i) {
//NumericVector funcVals(Xopt.nrow());
for(int ii=0; ii < funcVals.size(); ++ii){
funcVals(ii) = 0;
}
// Loop over points
for(int j = 0; j < Xopt.nrow(); ++j) {
if (!XoptSelected[j]) {
funcVals[j] = 0;
funcVal = 0;
// Loop over X0 (keptDelta) and selected Xopt to get funcVal
for(int l = 0; l < X0.nrow(); ++l) {
dist = sum(pow(Xopt(j, _) - X0(l, _), 2.0));
funcVals[j] += pow(qqX[l] / sqrt(dist), k);
funcVal += pow(qqX[l] / sqrt(dist), k);
}
// Loop over points already selected
for(int l = 0; l < Xopt.nrow(); ++l) {
if (XoptSelected[l]) {
dist = sum(pow(Xopt(j, _) - Xopt(l, _), 2.0));
funcVals[j] += pow(qqXopt[l] / sqrt(dist), k);
funcVal += pow(qqXopt[l] / sqrt(dist), k);
}
}
funcVal *= pow(qqXopt[j], k);
funcVals[j] *= pow(qqXopt[j], k);
// Check if it is the best
if ((funcValMinInd < 0) | (funcVal < funcValMin)) {
funcValMin = funcVal;
funcValMinInd = j;
}
}
} // end loop over Xopt points
XoptSelectedIndsOrder[i] = funcValMinInd;
XoptSelected[funcValMinInd] = true;
funcValMinInd = -1;
} // end loop to select n
/*# Get rest of points
Delta <- .01 * max(Y) #.01 * (n0 / (n + i)) ^ (1 / p) * max(Y)
#keep.Delta <- (Y > Delta)
keep.Delta <- ifelse(1:nrow(X) <= n0, Y > Delta, T)
}
*/
//return funcVals;
//return funcValMin;
//return qqXopt;//as<double>(f(X0(0,_)));
return XoptSelectedIndsOrder + 1;
}')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
Rcpp::cppFunction('
IntegerVector SMED_select2(Function f, int n, NumericMatrix X0, NumericMatrix Xopt) {
int p = X0.ncol();
int k = 4 * p;
// initiate values for X0
NumericVector Y(X0.nrow());
for (int i=0; i < Y.size(); ++i) {
Y[i] = as<double>(f(X0(i, _)));
}
NumericVector qqX(X0.nrow());
for (int i=0; i < qqX.size(); ++i) {
qqX[i] = pow(Y[i], -1.0 / (2 * p));
}
// initiate values for Xopt
NumericVector Yopt(Xopt.nrow());
for (int i=0; i < Yopt.size(); ++i) {
Yopt[i] = as<double>(f(Xopt(i, _)));
}
NumericVector qqXopt(Xopt.nrow());
for (int i=0; i < qqXopt.size(); ++i) {
qqXopt[i] = pow(Yopt[i], -1.0 / (2 * p));
}
double Delta = .01 * max(Y);
LogicalVector keepDelta = (Y > Delta);
IntegerVector XoptSelectedIndsOrder(n);
LogicalVector XoptSelected(Xopt.nrow(), false);
//double total = 0;
double dist = 0;
double funcValMin;
double funcValMinInd = -1;
double funcVal;
NumericVector funcVals(Xopt.nrow());
// Pick n next with SMED
for(int i = 0; i < n; ++i) {
//NumericVector funcVals(Xopt.nrow());
for(int ii=0; ii < funcVals.size(); ++ii){
funcVals(ii) = 0;
}
// Loop over points
for(int j = 0; j < Xopt.nrow(); ++j) {
if (!XoptSelected[j]) {
funcVals[j] = 0;
funcVal = 0;
// Loop over X0 (keptDelta) and selected Xopt to get funcVal
for(int l = 0; l < X0.nrow(); ++l) {
dist = sum(pow(Xopt(j, _) - X0(l, _), 2.0));
funcVals[j] += pow(qqX[l] / sqrt(dist), k);
funcVal += pow(qqX[l] / sqrt(dist), k);
}
// Loop over points already selected
for(int l = 0; l < Xopt.nrow(); ++l) {
if (XoptSelected[l]) {
dist = sum(pow(Xopt(j, _) - Xopt(l, _), 2.0));
funcVals[j] += pow(qqXopt[l] / sqrt(dist), k);
funcVal += pow(qqXopt[l] / sqrt(dist), k);
}
}
funcVal *= pow(qqXopt[j], k);
funcVals[j] *= pow(qqXopt[j], k);
// Check if it is the best
if ((funcValMinInd < 0) | (funcVal < funcValMin)) {
funcValMin = funcVal;
funcValMinInd = j;
}
}
} // end loop over Xopt points
XoptSelectedIndsOrder[i] = funcValMinInd;
XoptSelected[funcValMinInd] = true;
funcValMinInd = -1;
} // end loop to select n
/*# Get rest of points
Delta <- .01 * max(Y) #.01 * (n0 / (n + i)) ^ (1 / p) * max(Y)
#keep.Delta <- (Y > Delta)
keep.Delta <- ifelse(1:nrow(X) <= n0, Y > Delta, T)
}
*/
//return funcVals;
//return funcValMin;
//return qqXopt;//as<double>(f(X0(0,_)));
return XoptSelectedIndsOrder + 1;
}')
source('~/Git/DOE-code/../SMED-Code/SMED_select.R')
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
SMED_select(f=obj_func,p=ncol(X),n=L, X0=X, Xopt=Xnotrun)
SMED_select2(f=obj_func,n=L, X0=X, Xopt=Xnotrun)
a$run(1)
SMED_select(f=obj_func,p=ncol(X),n=L, X0=X, Xopt=Xnotrun)
SMED_select2(f=obj_func,n=L, X0=X, Xopt=Xnotrun)
source('~/Git/DOE-code/../SMED-Code/SMED_select.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
SMED_select(f=obj_func, n=L, X0=X, Xopt=Xnotrun)
source('~/Git/DOE-code/../SMED-Code/SMED_select.R')
source('~/Git/DOE-code/../SMED-Code/SMED_select.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
SMED_select(f=obj_func, n=L, X0=X, Xopt=Xnotrun)
SMED_select2(f=obj_func, n=L, X0=X, Xopt=Xnotrun)
a$run(2)
SMED_select(f=obj_func, n=L, X0=X, Xopt=Xnotrun)
SMED_select2(f=obj_func, n=L, X0=X, Xopt=Xnotrun)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
source('~/Git/SMED-Code/SMED_selectC.R')
SMED_select
SMED_selectSLOW
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
source('~/Git/SMED-Code/SMED_selectC.R')
source('~/Git/SMED-Code/SMED_selectC.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
system.time(a$run(20,noplot=T))
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot=T))
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot=T))
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('~/Git/SMED-Code/SMED_selectC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot=T))
source('~/Git/SMED-Code/SMED_selectC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot=T))
source('~/Git/SMED-Code/SMED_selectC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot=T))
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot=T))
%>%
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=5, reps = 3, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
source('~/Git/DOE-code/compare_adaptconcept.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=5, reps = 3, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
tdf <- data.frame(a=1:3,b=c(4,4,5))
plyr::dlply(tdf, .(b))
plyr::dlply(tdf, .('b'))
plyr::dlply(tdf, c('b'))
source('~/Git/DOE-code/compare_adaptconcept.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=5, reps = 3, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=15, reps = 5, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=15, reps = 5, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=15, reps = 5, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
Xb
e
1*Q
print(Q)
e1
N
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=15, reps = 5, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
source('~/Git/DOE-code/sFFLHD.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=15, reps = 5, plot.after=c(3), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=15, reps = 3, plot.after=c(5,10), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
source('~/Git/DOE-code/compare_adaptconcept.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=30, reps = 3, plot.after=c(10,20), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
source('~/Git/DOE-code/sFFLHD.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=30, reps = 3, plot.after=c(10,20), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=30, reps = 3, plot.after=c(10,20), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=30, reps = 3, plot.after=c(10,20), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
force_old
force_pvar
rand1
newL
is.null(newL)
newL
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
system.time(compare.adapt(func=banana, D=2, L=4, g=3, n0=8, batches=30, reps = 3, plot.after=c(10,20), objs=c("nonadapt", "pvar", "grad"),forces=c("old"),force.vals = c(.2)))
rand1
newL
Xnotrun
rand1
rand1
rand1
newL
newL
rand1
rand1
rand1
newL
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=.2)
a$run(1)
force_pvar
porce_old
force_old
rand1
a$run(1)
rand1
a$run(1)
rand1
a$run(1)
rand1
newL
newL
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=2)
a$run(1)
X
a$run(1)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=2)
a$run(1)
iteration
newL
a$run(1)
newL
newL
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=2)
a$run(1)
a$run(1)
SMED_selectC(f=mod$predict.var, n=L, X0=X, Xopt=Xnotrun)
order(mod$predict.var(Xnotrun), decreasing=T)[1:L]
a$run(1)
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=2)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=2)
a$run(1)
a$run(1)
a$run(20,plotlastonly = T)
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=10)
a$run(20,plotlastonly = T)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=10)
a$run(20,plotlastonly = T)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=4,n0=8,func=banana, obj="grad", force_pvar=10)
a$run(20,plotlastonly = T)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
l <- lineprof::lineprof(a$run(1))
shine(l)
lineprof::shine(l)
l <- lineprof::lineprof(a$run(1,noplot = T))
lineprof::shine(l)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
source('~/Git/DOE-code/sFFLHD.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,plotlastonly = T))
system.time(a$run(20,noplot = T))
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot = T))
source('~/Git/DOE-code/sFFLHD.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
system.time(a$run(20,noplot = T))
source('~/Git/DOE-code/sFFLHD.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
shiny::runApp('shiny/adaptconcept3_sFFLHD_RC')
shiny::runApp('shiny/adaptconcept3_sFFLHD_RC')
source('~/Git/DOE-code/shiny/adaptconcept3_sFFLHD_RC/UGP.R')
UGP()
UGP(X=matrix(1:10,ncol=1), Z=runif(10))
tu <- UGP(X=matrix(1:10,ncol=1), Z=runif(10))
tu$predict(3)
tu$update()
tu$predict(3)
source('~/Git/DOE-code/shiny/adaptconcept3_sFFLHD_RC/UGP.R')
tu <- UGP(X=matrix(1:10,ncol=1), Z=runif(10))
tu$predict(3)
XX
tu$predict(3)
tu$predict(3)
.predict
tu <- UGP(X=matrix(1:10,ncol=1), Z=runif(10), package="laGP")
tu$predict(3)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(1)
a$run(1)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(1)
X
UGP(package="laGP")
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
UGP
UGP$new()
class(UGP$new())
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('sFFLHD.R')
library("UGP")
source("adaptconcept_helpers.R")
require(mlegp)
require(GPfit)
require(contourfilled)
require(TestFunctions)
source('LHS.R')
source("RFF_test.R")
source("/Users/collin/Git/SMED-Code/SMED_select.R")
source("../SMED/SMED-Code/SMED_select.R")
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(1)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(1)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0, package="mlegp")
a$run(1)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('sFFLHD.R')
library("UGP")
source("adaptconcept_helpers.R")
require(mlegp)
require(GPfit)
require(contourfilled)
require(TestFunctions)
source('LHS.R')
source("RFF_test.R")
source("/Users/collin/Git/SMED-Code/SMED_select.R")
source("../SMED/SMED-Code/SMED_select.R")
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source("/Users/collin/Git/SMED-Code/SMED_selectC.R")
source("../SMED/SMED-Code/SMED_selectC.R")
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
X
Z
X
X
.self$X
X
nrow(X)
Xnotrun
obj_func
obj_func(c(.5,.5))
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
X
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
source('sFFLHD.R')
library("UGP")
source("adaptconcept_helpers.R")
require(mlegp)
require(GPfit)
require(contourfilled)
require(TestFunctions)
source('LHS.R')
source("RFF_test.R")
source("/Users/collin/Git/SMED-Code/SMED_select.R")
source("../SMED/SMED-Code/SMED_select.R")
source("/Users/collin/Git/SMED-Code/SMED_selectC.R")
source("../SMED/SMED-Code/SMED_selectC.R")
gaussian1 <- function(xx) exp(-sum((xx-.5)^2)/2/.01)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(2)
a$run(2)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(20, plotlastonly = T)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(20, plotlastonly = T)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(20, plotlastonly = T)
source('~/Git/DOE-code/adaptconcept2_sFFLHD_RC.R')
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=gaussian1, obj="grad", n0=0)
a$run(20, plotlastonly = T)
a <- adapt.concept2.sFFLHD.RC(D=2,L=3,func=sinumoid, obj="grad", n0=0)
a$run(20, plotlastonly = T)
shiny::runApp('shiny/adaptconcept3_sFFLHD_RC')
runApp('shiny/adaptconcept3_sFFLHD_RC')
runApp('shiny/adaptconcept3_sFFLHD_RC')
runApp('shiny/adaptconcept3_sFFLHD_RC')
runApp('shiny/adaptconcept3_sFFLHD_RC')
